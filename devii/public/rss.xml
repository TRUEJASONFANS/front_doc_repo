<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[My Awesome Blog]]></title><description><![CDATA[I write about code 'n stuff]]></description><link>https://alyssaphacker.com</link><image><url>https://alyssaphacker.com/icon.png</url><title>My Awesome Blog</title><link>https://alyssaphacker.com</link></image><generator>RSS for Node</generator><lastBuildDate>Mon, 23 Jan 2023 13:10:37 GMT</lastBuildDate><atom:link href="https://alyssaphacker.com/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Sat, 01 Jan 2022 04:00:00 GMT</pubDate><copyright><![CDATA[2023 truejasonfans]]></copyright><language><![CDATA[en]]></language><managingEditor><![CDATA[wudixiaowushi@163.com]]></managingEditor><webMaster><![CDATA[wudixiaowushi@163.com]]></webMaster><ttl>60</ttl><item><title><![CDATA[Aync/await sharing]]></title><description><![CDATA[<h1 id="aync">aync</h1>
<h2 id="ayncawait">为什么引入aync/await</h2>
<p>它们减少了 promises 的样板，且减少了 promise 链的“不破坏链条”的限制。</p>
<p>当 ES2015 中引入 Promise 时，它们旨在解决异步代码的问题，并且确实做到了，但是在 ES2015 和 ES2017 断开的两年中，很明显，promise 不可能成为最终的解决方案。</p>
<p>Promise 被引入了用于解决著名的回调地狱问题，但是它们自身引入了复杂性以及语法复杂性。</p>
<p>它们是很好的原语，可以向开发人员公开更好的语法，因此，当时机合适时，我们得到了异步函数。</p>
<p>它们使代码看起来像是同步的，但它是异步的并且在后台无阻塞。</p>
<ol>
<li>普通函数加上aync关键字　表示返回一个promise</li>
<li>即使没有显式地这样做，它也会在内部使它返回 promise。</li>
</ol>
<pre><code class="ts language-ts">const aFunction = async () =&gt; {
  return '测试'
}

aFunction().then(alert) // 这会 alert '测试'
</code></pre>
<p>跟以下代码一样无差别</p>
<pre><code class="ts language-ts">const aFunction = () =&gt; {
  return Promise.resolve('测试')
}

aFunction().then(alert) // 这会 alert '测试'
</code></pre>
<ol start="3">
<li>代码更容易阅读</li>
</ol>
<pre><code class="ts language-ts">const getFirstUserData = () =&gt; {
  return fetch('/users.tson') // 获取用户列表
    .then(response =&gt; response.tson()) // 解析 tsON
    .then(users =&gt; users[0]) // 选择第一个用户
    .then(user =&gt; fetch(`/users/${user.name}`)) // 获取用户数据
    .then(userResponse =&gt; userResponse.tson()) // 解析 tsON
}

getFirstUserData()
</code></pre>
<p>vs</p>
<pre><code class="ts language-ts">const getFirstUserData = async () =&gt; {
  const response = await fetch('/users.tson') // 获取用户列表
  const users = await response.tson() // 解析 tsON
  const user = users[0] // 选择第一个用户
  const userResponse = await fetch(`/users/${user.name}`) // 获取用户数据
  const userData = await userResponse.tson() // 解析 tsON
  return userData
}

getFirstUserData()
</code></pre>
<ol start="4">
<li>适用于串型模型</li>
</ol>
<pre><code class="ts language-ts">const promiseToDoSomething = () =&gt; {
  return new Promise(resolve =&gt; {
    setTimeout(() =&gt; resolve('做些事情'), 10000)
  })
}

const watchOverSomeoneDoingSomething = async () =&gt; {
  const something = await promiseToDoSomething()
  return something + ' 查看'
}

const watchOverSomeoneWatchingSomeoneDoingSomething = async () =&gt; {
  const something = await watchOverSomeoneDoingSomething()
  return something + ' 再次查看'
}

watchOverSomeoneWatchingSomeoneDoingSomething().then(res =&gt; {
  console.log(res)
})
</code></pre>
<ol start="5">
<li>更适合调试
调试 promise 很难，因为调试器不会跳过异步的代码。</li>
</ol>
<p>Async/await 使这非常容易，因为对于编译器而言，它就像同步代码一样。</p>
<p><a href="https://www.cnblogs.com/fundebug/p/6667725.html">Async/Await替代Promise的6个理由</a></p>]]></description><link>https://alyssaphacker.com/blog/async</link><guid isPermaLink="true">https://alyssaphacker.com/blog/async</guid><category><![CDATA[node]]></category><dc:creator><![CDATA[Zhongwei]]></dc:creator><pubDate>Sat, 04 Dec 2021 16:00:00 GMT</pubDate></item><item><title><![CDATA[module 介绍]]></title><description><![CDATA[<h1 id="">模块化</h1>
<h2 id="commomjs">CommomJS</h2>
<p>CommonJS模块规范
Node应用由模块组成，采用CommonJS模块规范。</p>
<p>根据这个规范，每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</p>
<p>CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。</p>
<pre><code class="ts language-ts">var x = 5;
var addX = function (value) {
  return value + x;
};
module.exports.x = x;
module.exports.addX = addX;
</code></pre>
<p>上面代码通过module.exports输出变量x和函数addX。</p>
<p>require方法用于加载模块。</p>
<pre><code class="ts language-ts">var example = require('./example.js');

console.log(example.x); // 5
console.log(example.addX(1)); // 6
</code></pre>
<p>exports 与 module.exports
优先使用 module.exports</p>
<p>为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令</p>
<pre><code class="ts language-ts">let exports = module.exports;
</code></pre>
<p>不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。</p>
<pre><code class="ts language-ts">let exports = module.exports;
let appid = '123456'
// 错误写法
exports = {
  appid
}
// 正确写法
exports.appid = appid
</code></pre>
<h2 id="es6">ES6 规范</h2>
<p>使用 import , export来导入和导出模块
```ts 
// utils.js
export const appid = '123234'
export function getAppid(){
  return '123456'
}</p>
<p>import {appid, getAppid} from './utils' //导入多个模块
import * as utils from 'utils';
console.log(appid)// 123234
console.log(getAppid()) //</p>
<pre><code>### export default
为模块指定默认输出
</code></pre>
<p>ts
// utils.js
// 错误写法 
// export default const appid = '123456'
// 正确写法
const appid = '123456'
export default appid</p>
<p>//----------------------------
import utils from './utils'
console.log(utils) // 123456</p>
<pre><code>
</code></pre>
<p>ts
import { foo, bar } from ‘./utils’ // 导入多个导出
import * as utils from ‘utils’ // 作为命名空间导入整个模块
import utils from ‘utils’ // 导入默认值
import utils , { foo , bar } from ‘./utils’ // 导入多个导出与默认导出
import { foo , bar } , * as utils from ‘utils’ // 导入命名空间整个模块与多个导出
import(’./utils’).then (res) =&gt; { // do something} // import动态导入函数，当使用它的时候，会返回一个promise。
let module = await import(’./utils’) // 支持await关键字
```</p>]]></description><link>https://alyssaphacker.com/blog/module</link><guid isPermaLink="true">https://alyssaphacker.com/blog/module</guid><category><![CDATA[node]]></category><dc:creator><![CDATA[Zhongwei]]></dc:creator><pubDate>Mon, 02 Jan 2023 13:59:34 GMT</pubDate></item><item><title><![CDATA[Promising sharing]]></title><description><![CDATA[<h1 id="promise">Promise 总结</h1>
<h2 id="promise-1">创建promise</h2>
<pre><code class="ts language-ts">let done = true

const isItDoneYet = new Promise((resolve, reject) =&gt; {
  if (done) {
    const workDone = '这是创建的东西'
    resolve(workDone)
  } else {
    const why = '仍然在处理其他事情'
    reject(why)
  }
})
</code></pre>
<h2 id="promise-2">消费 promise</h2>
<pre><code class="ts language-ts">const isItDoneYet = new Promise(/* ... 如上所述 ... */)
//...

const checkIfItsDone = () =&gt; {
  isItDoneYet
    .then(ok =&gt; {
      console.log(ok)
    })
    .catch(err =&gt; {
      console.error(err)
    })
}
checkIfItsDone();
</code></pre>
<h2 id="promise-3">链式promise</h2>
<p>Promise的返回值是另一个promise</p>
<pre><code class="ts language-ts">const status = response =&gt; {
  if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) {
    return Promise.resolve(response)
  }
  return Promise.reject(new Error(response.statusText))
}

const json = response =&gt; response.json()

fetch('/todos.json')
  .then(status)    // 注意，`status` 函数实际上在这里被调用，并且同样返回 promise，
  .then(json)      // 这里唯一的区别是的 `json` 函数会返回解决时传入 `data` 的 promise，
  .then(data =&gt; {  // 这是 `data` 会在此处作为匿名函数的第一个参数的原因。
    console.log('请求成功获得 JSON 响应', data)
  })
  .catch(error =&gt; {
    console.log('请求失败', error)
  })
</code></pre>
<p>## 处理错误
  处理错误
在上一章节的示例中，有个 catch 被附加到了 promise 链上。</p>
<p>当 promise 链中的任何内容失败并引发错误或拒绝 promise 时，则控制权会转到链中最近的 catch() 语句。</p>
<pre><code class="ts language-ts">new Promise((resolve, reject) =&gt; {
  throw new Error('错误')
}).catch(err =&gt; {
  console.error(err)
})

// 或

new Promise((resolve, reject) =&gt; {
  reject('错误')
}).catch(err =&gt; {
  console.error(err)
})
</code></pre>
<h2 id="promise-4">编排promise</h2>
<ol>
<li>Promise.all
f1, f2 都执行完毕</li>
</ol>
<pre><code class="ts language-ts">const f1 = fetch('/something.json')
const f2 = fetch('/something2.json')

Promise.all([f1, f2])
  .then(res =&gt; {
    console.log('结果的数组', res)
  })
  .catch(err =&gt; {
    console.error(err)
  })
</code></pre>
<ol start="2">
<li>Promise.race
当传给其的首个 promise 被解决时，则 Promise.race() 开始运行，并且只运行一次附加的回调（传入第一个被解决的 promise 的结果）.</li>
</ol>
<pre><code class="ts language-ts">const first = new Promise((resolve, reject) =&gt; {
  setTimeout(resolve, 500, '第一个')
})
const second = new Promise((resolve, reject) =&gt; {
  setTimeout(resolve, 100, '第二个')
})

Promise.race([first, second]).then(result =&gt; {
  console.log(result) // 第二个
})
</code></pre>]]></description><link>https://alyssaphacker.com/blog/promise</link><guid isPermaLink="true">https://alyssaphacker.com/blog/promise</guid><category><![CDATA[node]]></category><dc:creator><![CDATA[Zhongwei]]></dc:creator><pubDate>Sat, 04 Dec 2021 16:00:00 GMT</pubDate></item><item><title><![CDATA[Egg 介绍]]></title><description><![CDATA[<h1 id="eggjs">Egg.js</h1>
<p>Egg.js 为企业级框架和应用而生</p>
<h2 id="">设计原则</h2>
<p>Egg 的插件机制有很高的可扩展性，一个插件只做一件事（比如 Nunjucks 模板封装成了 egg-view-nunjucks、MySQL 数据库封装成了 egg-mysql）。Egg 通过框架聚合这些插件，并根据自己的业务场景定制配置，这样应用的开发成本就变得很低。</p>
<p>Egg 奉行『约定优于配置』，按照一套统一的约定进行应用开发，团队内部采用这种方式可以减少开发人员的学习成本，开发人员不再是『钉子』，可以流动起来。没有约定的团队，沟通成本是非常高的，比如有人会按目录分栈而其他人按目录分功能，开发者认知不一致很容易犯错。但约定不等于扩展性差，相反 Egg 有很高的扩展性，可以按照团队的约定定制框架。使用 Loader 可以让框架根据不同环境定义默认配置，还可以覆盖 Egg 的默认约定。</p>
<h2 id="-1">特点</h2>
<ol>
<li>提供基于 Egg 定制上层框架的能力</li>
<li>高度可扩展的插件机制</li>
<li>内置多进程管理</li>
<li>基于 Koa 开发，性能优异</li>
<li>框架稳定，测试覆盖率高</li>
<li>渐进式开发</li>
</ol>
<h2 id="demo">demo 示例</h2>
<p><a href="https://github.com/eggjs/examples">eggs example</a></p>
<h2 id="-2">目录结构</h2>
<pre><code>egg-project
├── package.json
├── app.js (可选)
├── agent.js (可选)
├── app
|   ├── router.js
│   ├── controller
│   |   └── home.js
│   ├── service (可选)
│   |   └── user.js
│   ├── middleware (可选)
│   |   └── response_time.js
│   ├── schedule (可选)
│   |   └── my_task.js
│   ├── public (可选)
│   |   └── reset.css
│   ├── view (可选)
│   |   └── home.tpl
│   └── extend (可选)
│       ├── helper.js (可选)
│       ├── request.js (可选)
│       ├── response.js (可选)
│       ├── context.js (可选)
│       ├── application.js (可选)
│       └── agent.js (可选)
├── config
|   ├── plugin.js
|   ├── config.default.js
│   ├── config.prod.js
|   ├── config.test.js (可选)
|   ├── config.local.js (可选)
|   └── config.unittest.js (可选)
└── test
    ├── middleware
    |   └── response_time.test.js
    └── controller
        └── home.test.js
</code></pre>
<p>如上，由框架约定的目录：</p>
<pre><code>app/router.js 用于配置 URL 路由规则，具体参见 Router。
app/controller/** 用于解析用户的输入，处理后返回相应的结果，具体参见 Controller。
app/service/** 用于编写业务逻辑层，可选，建议使用，具体参见 Service。
app/middleware/** 用于编写中间件，可选，具体参见 Middleware。
app/public/** 用于放置静态资源，可选，具体参见内置插件 egg-static。
app/extend/** 用于框架的扩展，可选，具体参见框架扩展。
config/config.{env}.js 用于编写配置文件，具体参见配置。
config/plugin.js 用于配置需要加载的插件，具体参见插件。
test/** 用于单元测试，具体参见单元测试。
app.js 和 agent.js 用于自定义启动时的初始化工作，可选，具体参见启动自定义。关于agent.js的作用参见Agent机制。
由内置插件约定的目录：

app/public/** 用于放置静态资源，可选，具体参见内置插件 egg-static。
app/schedule/** 用于定时任务，可选，具体参见定时任务。
若需自定义自己的目录规范，参见 Loader API

app/view/** 用于放置模板文件，可选，由模板插件约定，具体参见模板渲染。
app/model/** 用于放置领域模型，可选，由领域类相关插件约定，如 egg-sequelize。
</code></pre>
<h2 id="-3">内置对象</h2>
<p><a href="https://eggjs.org/zh-cn/basics/objects.html">内置对象</a></p>
<h3 id="application">Application</h3>
<p>Application 是全局应用对象，在一个应用中，只会实例化一个，它继承自 Koa.Application，在它上面我们可以挂载一些全局的方法和对象。我们可以轻松的在插件或者应用中扩展 Application 对象。</p>
<pre><code class="ts language-ts">module.exports = app =&gt; {
  app.once('server', server =&gt; {
    // websocket
  });
  app.on('error', (err, ctx) =&gt; {
    // report error
  });
  app.on('request', ctx =&gt; {
    // log receive request
  });
  app.on('response', ctx =&gt; {
    // ctx.starttime is set by framework
    const used = Date.now() - ctx.starttime;
    // log total cost
  });
};
</code></pre>
<h3 id="context">Context</h3>
<p>Context 是一个请求级别的对象，继承自 Koa.Context。在每一次收到用户请求时，框架会实例化一个 Context 对象，这个对象封装了这次用户请求的信息，并提供了许多便捷的方法来获取请求参数或者设置响应信息。框架会将所有的 Service 挂载到 Context 实例上，一些插件也会将一些其他的方法和对象挂载到它上面（egg-sequelize 会将所有的 model 挂载在 Context 上）。</p>
<h3 id="reqeustresponse">Reqeust &amp;&amp; Response</h3>
<ol>
<li>Request 是一个请求级别的对象，继承自 Koa.Request。封装了 Node.js 原生的 HTTP Request 对象，提供了一系列辅助方法获取 HTTP 请求常用参数。</li>
<li>Response 是一个请求级别的对象，继承自 Koa.Response。封装了 Node.js 原生的 HTTP Response 对象，提供了一系列辅助方法设置 HTTP 响应。</li>
</ol>
<h3 id="controller">Controller</h3>
<p>简单的说 Controller <strong>负责解析用户的输入，处理后返回相应的结果</strong>，例如</p>
<ul>
<li>在 RESTful 接口中，Controller 接受用户的参数，从数据库中查找内容返回给用户或者将用户的请求更新到数据库中。</li>
<li>在 HTML 页面请求中，Controller 根据用户访问不同的 URL，渲染不同的模板得到 HTML 返回给用户。</li>
<li>在代理服务器中，Controller 将用户的请求转发到其他服务器上，并将其他服务器的处理结果返回给用户。
框架推荐 Controller 层主要对用户的请求参数进行处理（校验、转换），然后调用对应的 service 方法处理业务，得到业务结果后封装并返回：</li>
</ul>
<ol>
<li>获取用户通过 HTTP 传递过来的请求参数。</li>
<li>校验、组装参数。</li>
<li>调用 Service 进行业务处理，必要时处理转换 Service 的返回结果，让它适应用户的需求。</li>
<li>通过 HTTP 将结果响应给用户。</li>
</ol>
<pre><code class="ts language-ts">// app/controller/post.js
const Controller = require('egg').Controller;
class PostController extends Controller {
  async create() {
    const { ctx, service } = this;
    const createRule = {
      title: { type: 'string' },
      content: { type: 'string' },
    };
    // 校验参数
    ctx.validate(createRule);
    // 组装参数
    const author = ctx.session.userId;
    const req = Object.assign(ctx.request.body, { author });
    // 调用 Service 进行业务处理
    const res = await service.post.create(req);
    // 设置响应内容和响应状态码
    ctx.body = { id: res.id };
    ctx.status = 201;
  }
}
module.exports = PostController;
</code></pre>
<h3 id="service">Service</h3>
<p>简单来说，Service 就是在复杂业务场景下用于做业务逻辑封装的一个抽象层，提供这个抽象有以下几个好处：</p>
<ul>
<li>保持 Controller 中的逻辑更加简洁。</li>
<li>保持业务逻辑的独立性，抽象出来的 Service 可以被多个 Controller 重复调用。</li>
<li>将逻辑和展现分离，更容易编写测试用例，测试用例的编写具体可以查看这里。</li>
</ul>
<pre><code class="ts language-ts">// app/service/user.js
const Service = require('egg').Service;

class UserService extends Service {
  async find(uid) {
    const user = await this.ctx.db.query('select * from user where uid = ?', uid);
    return user;
  }
}

module.exports = UserService;
</code></pre>
<h3 id="helper">Helper</h3>
<p>Helper 用来提供一些实用的 utility 函数。它的作用在于我们可以将一些常用的动作抽离在 helper.js 里面成为一个独立的函数，这样可以用 JavaScript 来写复杂的逻辑，避免逻辑分散各处，同时可以更好的编写测试用例。</p>
<p>Helper 自身是一个类，有和 Controller 基类一样的属性，它也会在每次请求时进行实例化，因此 Helper 上的所有函数也能获取到当前请求相关的上下文信息。</p>
<pre><code class="ts language-ts">// app/controller/user.js
class UserController extends Controller {
  async fetch() {
    const { app, ctx } = this;
    const id = ctx.query.id;
    const user = app.cache.get(id);
    ctx.body = ctx.helper.formatUser(user);
  }
}
</code></pre>
<h3 id="config">Config</h3>
<h3 id="logger">Logger</h3>
<h3 id="subscription">Subscription</h3>
<p>订阅模型是一种比较常见的开发模式，譬如消息中间件的消费者或调度任务。因此我们提供了 Subscription 基类来规范化这个模式。</p>
<p>可以通过以下方式来引用 Subscription 基类：</p>
<pre><code class="ts language-ts">const Subscription = require('egg').Subscription;

class Schedule extends Subscription {
  // 需要实现此方法
  // subscribe 可以为 async function 或 generator function
  async subscribe() {}
}
</code></pre>
<h2 id="eggjskoa">Egg.js 与 Koa</h2>
<ol>
<li><p>Egg 继承于 Koa</p></li>
<li><p>Koa 中间件模型
<img src="https://camo.githubusercontent.com/d80cf3b511ef4898bcde9a464de491fa15a50d06/68747470733a2f2f7261772e6769746875622e636f6d2f66656e676d6b322f6b6f612d67756964652f6d61737465722f6f6e696f6e2e706e67" alt="Koa" /></p></li>
<li><p>Koa 中间件的<a href="https://zhuanlan.zhihu.com/p/141890366">实现原理</a></p></li>
</ol>
<p>例如添加一个异常处理的中间件：</p>
<pre><code class="ts language-ts">async function onerror(ctx, next) {
  try {
    await next();
  } catch (err) {
    ctx.app.emit('error', err);
    ctx.body = 'server error';
    ctx.status = err.status || 500;
  }
}
</code></pre>
<ol start="3">
<li>扩展
在基于 Egg 的框架或者应用中，我们可以通过定义 <code>app/extend/{application,context,request,response}.js</code> 来扩展 Koa 中对应的四个对象的原型，通过这个功能，我们可以快速的增加更多的辅助方法，例如我们在 app/extend/context.js 中写入下列代码：</li>
</ol>
<pre><code class="ts language-ts">// app/extend/context.js
module.exports = {
  get isIOS() {
    const iosReg = /iphone|ipad|ipod/i;
    return iosReg.test(this.get('user-agent'));
  },
};
</code></pre>
<pre><code class="ts language-ts">在 Controller 中，我们就可以使用到刚才定义的这个便捷属性了：

// app/controller/home.js
exports.handler = ctx =&gt; {
  ctx.body = ctx.isIOS
    ? 'Your operating system is iOS.'
    : 'Your operating system is not iOS.';
};
</code></pre>
<h2 id="-4">插件</h2>
<p>在 Express 和 Koa 中，经常会引入许许多多的中间件来提供各种各样的功能，例如引入 koa-session 提供 Session 的支持，引入 koa-bodyparser 来解析请求 body。而 Egg 提供了一个更加强大的插件机制，让这些独立领域的功能模块可以更加容易编写。</p>
<p>一个插件可以包含</p>
<p>extend：扩展基础对象的上下文，提供各种工具类、属性。
middleware：增加一个或多个中间件，提供请求的前置、后置处理逻辑。
config：配置各个环境下插件自身的默认配置项。
一个独立领域下的插件实现，可以在代码维护性非常高的情况下实现非常完善的功能，而插件也支持配置各个环境下的默认（最佳）配置，让我们使用插件的时候几乎可以不需要修改配置项。</p>
<p><a href="egg-security">https://github.com/eggjs/egg-security</a> 插件就是一个典型的例子。</p>]]></description><link>https://alyssaphacker.com/blog/egg</link><guid isPermaLink="true">https://alyssaphacker.com/blog/egg</guid><category><![CDATA[node]]></category><dc:creator><![CDATA[Zhongwei]]></dc:creator><pubDate>Mon, 29 Nov 2021 16:00:00 GMT</pubDate></item><item><title><![CDATA[Node介绍part 1]]></title><description><![CDATA[<h2 id="node">node 简史</h2>
<p>[http://nodejs.cn/learn/a-brief-history-of-nodejs]</p>
<h2 id="node-1">node 的优点</h2>
<ol>
<li>runtime: Node js 是一个开源和跨平台的 JavaScript 运行时环境</li>
<li>性能好:Node.js 在浏览器之外运行 V8 JavaScript 引擎（Google Chrome 的内核）</li>
<li>单线程管理数千链接，基于事件模型。适用于I/O密集型</li>
</ol>
<pre><code class="ts language-ts">const http = require('http')

const hostname = '127.0.0.1'
const port = 3000

const server = http.createServer((req, res) =&gt; {
  res.statusCode = 200
  res.setHeader('Content-Type', 'text/plain')
  res.end('Hello World\n')
})

server.listen(port, hostname, () =&gt; {
  console.log(`Server running at http://${hostname}:${port}/`)
})
</code></pre>
<h2 id="">安装</h2>
<ol>
<li>下载node binary, 设置环境变量, 轻量类似于python.</li>
<li>建议使用nvm管理不同node版本，方便切换不同的node版本</li>
</ol>
<h2 id="-1">异步编程</h2>
<ol>
<li>异步编程与回调</li>
<li>定时器</li>
<li>Promise</li>
<li>Async 与 Await</li>
<li>闭包</li>
<li>事件循环</li>
</ol>
<h2 id="-2">事件循环</h2>
<ol>
<li>Node.js JavaScript 代码运行在单个线程上。 每次只处理一件事。</li>
</ol>
<p>这个限制实际上非常有用，因为它大大简化了编程方式，而不必担心并发问题。</p>
<p>只需要注意如何编写代码，并避免任何可能阻塞线程的事情，例如同步的网络调用或无限的循环。</p>
<p>通常，在大多数浏览器中，每个浏览器选项卡都有一个事件循环，以使每个进程都隔离开，并避免使用无限的循环或繁重的处理来阻止整个浏览器的网页。</p>
<p>该环境管理多个并发的事件循环，例如处理 API 调用。 Web 工作进程也运行在自己的事件循环中。</p>
<p>主要需要关心代码会在单个事件循环上运行，并且在编写代码时牢记这一点，以避免阻塞它。</p>
<h3 id="-3">堆栈调用</h3>
<p>调用堆栈是一个 LIFO 队列（后进先出）。</p>
<p>事件循环不断地检查调用堆栈，以查看是否需要运行任何函数。</p>
<p>当执行时，它会将找到的所有函数调用添加到调用堆栈中，并按顺序执行每个函数。</p>
<p>你知道在调试器或浏览器控制台中可能熟悉的错误堆栈跟踪吗？ 浏览器在调用堆栈中查找函数名称，以告知你是哪个函数发起了当前的调用：</p>
<h3 id="-4">阻塞事件循环</h3>
<p>任何花费太长时间才能将控制权返回给事件循环的 JavaScript 代码，都会阻塞页面中任何 JavaScript 代码的执行，甚至阻塞 UI 线程，并且用户无法单击浏览、滚动页面等。</p>
<p>JavaScript 中几乎所有的 I/O 基元都是非阻塞的。 网络请求、文件系统操作等。 被阻塞是个异常，这就是 JavaScript 如此之多基于回调（最近越来越多基于 promise 和 async/await）的原因。</p>
<h3 id="-5">消息队列 与 作业队列</h3>
<p>什么属于消息队列事件</p>
<ol>
<li>setTimeout()</li>
<li>用户触发的事件比如键盘，单击, onLoad</li>
</ol>
<p>事件循环会赋予调用堆栈优先级，它首先处理在调用堆栈中找到的所有东西，一旦其中没有任何东西，便开始处理消息队列中的东西。
ECMAScript 2015 引入了作业队列的概念，Promise 使用了该队列（也在 ES6/ES2015 中引入）。 这种方式会尽快地执行异步函数的结果，而不是放在调用堆栈的末尾。</p>
<p>堆栈调用 -&gt; 作业队列 -&gt;  消息队列
有个游乐园中过山车的比喻很好：消息队列将你排在队列的后面（在所有其他人的后面），你不得不等待你的回合，而工作队列则是快速通道票，这样你就可以在完成上一次乘车后立即乘坐另一趟车。</p>
<pre><code class="ts language-ts">const bar = () =&gt; console.log('bar')

const baz = () =&gt; console.log('baz')

const foo = () =&gt; {
  console.log('foo')
  setTimeout(bar, 0)
  new Promise((resolve, reject) =&gt;
    resolve('应该在 baz 之后、bar 之前')
  ).then(resolve =&gt; console.log(resolve))
  baz()
}

foo()
</code></pre>]]></description><link>https://alyssaphacker.com/blog/node</link><guid isPermaLink="true">https://alyssaphacker.com/blog/node</guid><category><![CDATA[node]]></category><dc:creator><![CDATA[Zhongwei]]></dc:creator><pubDate>Mon, 29 Nov 2021 16:00:00 GMT</pubDate></item></channel></rss>
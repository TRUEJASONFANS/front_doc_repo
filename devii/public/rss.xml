<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[My Awesome Blog]]></title><description><![CDATA[I write about code 'n stuff]]></description><link>https://alyssaphacker.com</link><image><url>https://alyssaphacker.com/icon.png</url><title>My Awesome Blog</title><link>https://alyssaphacker.com</link></image><generator>RSS for Node</generator><lastBuildDate>Mon, 09 Jan 2023 16:14:37 GMT</lastBuildDate><atom:link href="https://alyssaphacker.com/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Sat, 01 Jan 2022 04:00:00 GMT</pubDate><copyright><![CDATA[2023 truejasonfans]]></copyright><language><![CDATA[en]]></language><managingEditor><![CDATA[wudixiaowushi@163.com]]></managingEditor><webMaster><![CDATA[wudixiaowushi@163.com]]></webMaster><ttl>60</ttl><item><title><![CDATA[module 介绍]]></title><description><![CDATA[<h1 id="">模块化</h1>
<h2 id="commomjs">CommomJS</h2>
<p>CommonJS模块规范
Node应用由模块组成，采用CommonJS模块规范。</p>
<p>根据这个规范，每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</p>
<p>CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。</p>
<pre><code class="ts language-ts">var x = 5;
var addX = function (value) {
  return value + x;
};
module.exports.x = x;
module.exports.addX = addX;
</code></pre>
<p>上面代码通过module.exports输出变量x和函数addX。</p>
<p>require方法用于加载模块。</p>
<pre><code class="ts language-ts">var example = require('./example.js');

console.log(example.x); // 5
console.log(example.addX(1)); // 6
</code></pre>
<p>exports 与 module.exports
优先使用 module.exports</p>
<p>为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令</p>
<pre><code class="ts language-ts">let exports = module.exports;
</code></pre>
<p>不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。</p>
<pre><code class="ts language-ts">let exports = module.exports;
let appid = '123456'
// 错误写法
exports = {
  appid
}
// 正确写法
exports.appid = appid
</code></pre>
<h2 id="es6">ES6 规范</h2>
<p>使用 import , export来导入和导出模块
```ts 
// utils.js
export const appid = '123234'
export function getAppid(){
  return '123456'
}</p>
<p>import {appid, getAppid} from './utils' //导入多个模块
import * as utils from 'utils';
console.log(appid)// 123234
console.log(getAppid()) //</p>
<pre><code>### export default
为模块指定默认输出
</code></pre>
<p>ts
// utils.js
// 错误写法 
// export default const appid = '123456'
// 正确写法
const appid = '123456'
export default appid</p>
<p>//----------------------------
import utils from './utils'
console.log(utils) // 123456</p>
<pre><code>
</code></pre>
<p>ts
import { foo, bar } from ‘./utils’ // 导入多个导出
import * as utils from ‘utils’ // 作为命名空间导入整个模块
import utils from ‘utils’ // 导入默认值
import utils , { foo , bar } from ‘./utils’ // 导入多个导出与默认导出
import { foo , bar } , * as utils from ‘utils’ // 导入命名空间整个模块与多个导出
import(’./utils’).then (res) =&gt; { // do something} // import动态导入函数，当使用它的时候，会返回一个promise。
let module = await import(’./utils’) // 支持await关键字
————————————————
版权声明：本文为CSDN博主「前端小小白zyw」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/Vue2018/article/details/85787759
```</p>]]></description><link>https://alyssaphacker.com/blog/module</link><guid isPermaLink="true">https://alyssaphacker.com/blog/module</guid><category><![CDATA[node]]></category><dc:creator><![CDATA[Zhongwei]]></dc:creator><pubDate>Mon, 02 Jan 2023 13:59:34 GMT</pubDate></item><item><title><![CDATA[Aync/await sharing]]></title><description><![CDATA[<h1 id="aync">aync</h1>
<h2 id="ayncawait">为什么引入aync/await</h2>
<p>它们减少了 promises 的样板，且减少了 promise 链的“不破坏链条”的限制。</p>
<p>当 ES2015 中引入 Promise 时，它们旨在解决异步代码的问题，并且确实做到了，但是在 ES2015 和 ES2017 断开的两年中，很明显，promise 不可能成为最终的解决方案。</p>
<p>Promise 被引入了用于解决著名的回调地狱问题，但是它们自身引入了复杂性以及语法复杂性。</p>
<p>它们是很好的原语，可以向开发人员公开更好的语法，因此，当时机合适时，我们得到了异步函数。</p>
<p>它们使代码看起来像是同步的，但它是异步的并且在后台无阻塞。</p>
<ol>
<li>普通函数加上aync关键字　表示返回一个promise</li>
<li>即使没有显式地这样做，它也会在内部使它返回 promise。</li>
</ol>
<pre><code class="ts language-ts">const aFunction = async () =&gt; {
  return '测试'
}

aFunction().then(alert) // 这会 alert '测试'
</code></pre>
<p>跟以下代码一样无差别</p>
<pre><code class="ts language-ts">const aFunction = () =&gt; {
  return Promise.resolve('测试')
}

aFunction().then(alert) // 这会 alert '测试'
</code></pre>
<ol start="3">
<li>代码更容易阅读</li>
</ol>
<pre><code class="ts language-ts">const getFirstUserData = () =&gt; {
  return fetch('/users.tson') // 获取用户列表
    .then(response =&gt; response.tson()) // 解析 tsON
    .then(users =&gt; users[0]) // 选择第一个用户
    .then(user =&gt; fetch(`/users/${user.name}`)) // 获取用户数据
    .then(userResponse =&gt; userResponse.tson()) // 解析 tsON
}

getFirstUserData()
</code></pre>
<p>vs</p>
<pre><code class="ts language-ts">const getFirstUserData = async () =&gt; {
  const response = await fetch('/users.tson') // 获取用户列表
  const users = await response.tson() // 解析 tsON
  const user = users[0] // 选择第一个用户
  const userResponse = await fetch(`/users/${user.name}`) // 获取用户数据
  const userData = await userResponse.tson() // 解析 tsON
  return userData
}

getFirstUserData()
</code></pre>
<ol start="4">
<li>适用于串型模型</li>
</ol>
<pre><code class="ts language-ts">const promiseToDoSomething = () =&gt; {
  return new Promise(resolve =&gt; {
    setTimeout(() =&gt; resolve('做些事情'), 10000)
  })
}

const watchOverSomeoneDoingSomething = async () =&gt; {
  const something = await promiseToDoSomething()
  return something + ' 查看'
}

const watchOverSomeoneWatchingSomeoneDoingSomething = async () =&gt; {
  const something = await watchOverSomeoneDoingSomething()
  return something + ' 再次查看'
}

watchOverSomeoneWatchingSomeoneDoingSomething().then(res =&gt; {
  console.log(res)
})
</code></pre>
<ol start="5">
<li>更适合调试
调试 promise 很难，因为调试器不会跳过异步的代码。</li>
</ol>
<p>Async/await 使这非常容易，因为对于编译器而言，它就像同步代码一样。</p>
<p><a href="https://www.cnblogs.com/fundebug/p/6667725.html">Async/Await替代Promise的6个理由</a></p>]]></description><link>https://alyssaphacker.com/blog/async</link><guid isPermaLink="true">https://alyssaphacker.com/blog/async</guid><category><![CDATA[node]]></category><dc:creator><![CDATA[Zhongwei]]></dc:creator><pubDate>Sat, 04 Dec 2021 16:00:00 GMT</pubDate></item><item><title><![CDATA[Promising sharing]]></title><description><![CDATA[<h1 id="promise">Promise 总结</h1>
<h2 id="promise-1">创建promise</h2>
<pre><code class="ts language-ts">let done = true

const isItDoneYet = new Promise((resolve, reject) =&gt; {
  if (done) {
    const workDone = '这是创建的东西'
    resolve(workDone)
  } else {
    const why = '仍然在处理其他事情'
    reject(why)
  }
})
</code></pre>
<h2 id="promise-2">消费 promise</h2>
<pre><code class="ts language-ts">const isItDoneYet = new Promise(/* ... 如上所述 ... */)
//...

const checkIfItsDone = () =&gt; {
  isItDoneYet
    .then(ok =&gt; {
      console.log(ok)
    })
    .catch(err =&gt; {
      console.error(err)
    })
}
checkIfItsDone();
</code></pre>
<h2 id="promise-3">链式promise</h2>
<p>Promise的返回值是另一个promise</p>
<pre><code class="ts language-ts">const status = response =&gt; {
  if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) {
    return Promise.resolve(response)
  }
  return Promise.reject(new Error(response.statusText))
}

const json = response =&gt; response.json()

fetch('/todos.json')
  .then(status)    // 注意，`status` 函数实际上在这里被调用，并且同样返回 promise，
  .then(json)      // 这里唯一的区别是的 `json` 函数会返回解决时传入 `data` 的 promise，
  .then(data =&gt; {  // 这是 `data` 会在此处作为匿名函数的第一个参数的原因。
    console.log('请求成功获得 JSON 响应', data)
  })
  .catch(error =&gt; {
    console.log('请求失败', error)
  })
</code></pre>
<p>## 处理错误
  处理错误
在上一章节的示例中，有个 catch 被附加到了 promise 链上。</p>
<p>当 promise 链中的任何内容失败并引发错误或拒绝 promise 时，则控制权会转到链中最近的 catch() 语句。</p>
<pre><code class="ts language-ts">new Promise((resolve, reject) =&gt; {
  throw new Error('错误')
}).catch(err =&gt; {
  console.error(err)
})

// 或

new Promise((resolve, reject) =&gt; {
  reject('错误')
}).catch(err =&gt; {
  console.error(err)
})
</code></pre>
<h2 id="promise-4">编排promise</h2>
<ol>
<li>Promise.all
f1, f2 都执行完毕</li>
</ol>
<pre><code class="ts language-ts">const f1 = fetch('/something.json')
const f2 = fetch('/something2.json')

Promise.all([f1, f2])
  .then(res =&gt; {
    console.log('结果的数组', res)
  })
  .catch(err =&gt; {
    console.error(err)
  })
</code></pre>
<ol start="2">
<li>Promise.race
当传给其的首个 promise 被解决时，则 Promise.race() 开始运行，并且只运行一次附加的回调（传入第一个被解决的 promise 的结果）.</li>
</ol>
<pre><code class="ts language-ts">const first = new Promise((resolve, reject) =&gt; {
  setTimeout(resolve, 500, '第一个')
})
const second = new Promise((resolve, reject) =&gt; {
  setTimeout(resolve, 100, '第二个')
})

Promise.race([first, second]).then(result =&gt; {
  console.log(result) // 第二个
})
</code></pre>]]></description><link>https://alyssaphacker.com/blog/promise</link><guid isPermaLink="true">https://alyssaphacker.com/blog/promise</guid><category><![CDATA[node]]></category><dc:creator><![CDATA[Zhongwei]]></dc:creator><pubDate>Sat, 04 Dec 2021 16:00:00 GMT</pubDate></item><item><title><![CDATA[Egg 介绍]]></title><description><![CDATA[<h1 id="eggjs">Egg.js</h1>
<p>Egg.js 为企业级框架和应用而生</p>
<h2 id="">设计原则</h2>
<p>Egg 的插件机制有很高的可扩展性，一个插件只做一件事（比如 Nunjucks 模板封装成了 egg-view-nunjucks、MySQL 数据库封装成了 egg-mysql）。Egg 通过框架聚合这些插件，并根据自己的业务场景定制配置，这样应用的开发成本就变得很低。</p>
<p>Egg 奉行『约定优于配置』，按照一套统一的约定进行应用开发，团队内部采用这种方式可以减少开发人员的学习成本，开发人员不再是『钉子』，可以流动起来。没有约定的团队，沟通成本是非常高的，比如有人会按目录分栈而其他人按目录分功能，开发者认知不一致很容易犯错。但约定不等于扩展性差，相反 Egg 有很高的扩展性，可以按照团队的约定定制框架。使用 Loader 可以让框架根据不同环境定义默认配置，还可以覆盖 Egg 的默认约定。</p>
<h2 id="-1">特点</h2>
<ol>
<li>提供基于 Egg 定制上层框架的能力</li>
<li>高度可扩展的插件机制</li>
<li>内置多进程管理</li>
<li>基于 Koa 开发，性能优异</li>
<li>框架稳定，测试覆盖率高</li>
<li>渐进式开发</li>
</ol>
<h2 id="demo">demo 示例</h2>
<p><a href="https://github.com/eggjs/examples">eggs example</a></p>
<h2 id="-2">目录结构</h2>
<pre><code>egg-project
├── package.json
├── app.js (可选)
├── agent.js (可选)
├── app
|   ├── router.js
│   ├── controller
│   |   └── home.js
│   ├── service (可选)
│   |   └── user.js
│   ├── middleware (可选)
│   |   └── response_time.js
│   ├── schedule (可选)
│   |   └── my_task.js
│   ├── public (可选)
│   |   └── reset.css
│   ├── view (可选)
│   |   └── home.tpl
│   └── extend (可选)
│       ├── helper.js (可选)
│       ├── request.js (可选)
│       ├── response.js (可选)
│       ├── context.js (可选)
│       ├── application.js (可选)
│       └── agent.js (可选)
├── config
|   ├── plugin.js
|   ├── config.default.js
│   ├── config.prod.js
|   ├── config.test.js (可选)
|   ├── config.local.js (可选)
|   └── config.unittest.js (可选)
└── test
    ├── middleware
    |   └── response_time.test.js
    └── controller
        └── home.test.js
</code></pre>
<p>如上，由框架约定的目录：</p>
<pre><code>app/router.js 用于配置 URL 路由规则，具体参见 Router。
app/controller/** 用于解析用户的输入，处理后返回相应的结果，具体参见 Controller。
app/service/** 用于编写业务逻辑层，可选，建议使用，具体参见 Service。
app/middleware/** 用于编写中间件，可选，具体参见 Middleware。
app/public/** 用于放置静态资源，可选，具体参见内置插件 egg-static。
app/extend/** 用于框架的扩展，可选，具体参见框架扩展。
config/config.{env}.js 用于编写配置文件，具体参见配置。
config/plugin.js 用于配置需要加载的插件，具体参见插件。
test/** 用于单元测试，具体参见单元测试。
app.js 和 agent.js 用于自定义启动时的初始化工作，可选，具体参见启动自定义。关于agent.js的作用参见Agent机制。
由内置插件约定的目录：

app/public/** 用于放置静态资源，可选，具体参见内置插件 egg-static。
app/schedule/** 用于定时任务，可选，具体参见定时任务。
若需自定义自己的目录规范，参见 Loader API

app/view/** 用于放置模板文件，可选，由模板插件约定，具体参见模板渲染。
app/model/** 用于放置领域模型，可选，由领域类相关插件约定，如 egg-sequelize。
</code></pre>
<h2 id="-3">内置对象</h2>
<p><a href="https://eggjs.org/zh-cn/basics/objects.html">内置对象</a></p>
<h3 id="application">Application</h3>
<p>Application 是全局应用对象，在一个应用中，只会实例化一个，它继承自 Koa.Application，在它上面我们可以挂载一些全局的方法和对象。我们可以轻松的在插件或者应用中扩展 Application 对象。</p>
<pre><code class="ts language-ts">module.exports = app =&gt; {
  app.once('server', server =&gt; {
    // websocket
  });
  app.on('error', (err, ctx) =&gt; {
    // report error
  });
  app.on('request', ctx =&gt; {
    // log receive request
  });
  app.on('response', ctx =&gt; {
    // ctx.starttime is set by framework
    const used = Date.now() - ctx.starttime;
    // log total cost
  });
};
</code></pre>
<h3 id="context">Context</h3>
<p>Context 是一个请求级别的对象，继承自 Koa.Context。在每一次收到用户请求时，框架会实例化一个 Context 对象，这个对象封装了这次用户请求的信息，并提供了许多便捷的方法来获取请求参数或者设置响应信息。框架会将所有的 Service 挂载到 Context 实例上，一些插件也会将一些其他的方法和对象挂载到它上面（egg-sequelize 会将所有的 model 挂载在 Context 上）。</p>
<h3 id="reqeustresponse">Reqeust &amp;&amp; Response</h3>
<ol>
<li>Request 是一个请求级别的对象，继承自 Koa.Request。封装了 Node.js 原生的 HTTP Request 对象，提供了一系列辅助方法获取 HTTP 请求常用参数。</li>
<li>Response 是一个请求级别的对象，继承自 Koa.Response。封装了 Node.js 原生的 HTTP Response 对象，提供了一系列辅助方法设置 HTTP 响应。</li>
</ol>
<h3 id="controller">Controller</h3>
<p>简单的说 Controller <strong>负责解析用户的输入，处理后返回相应的结果</strong>，例如</p>
<ul>
<li>在 RESTful 接口中，Controller 接受用户的参数，从数据库中查找内容返回给用户或者将用户的请求更新到数据库中。</li>
<li>在 HTML 页面请求中，Controller 根据用户访问不同的 URL，渲染不同的模板得到 HTML 返回给用户。</li>
<li>在代理服务器中，Controller 将用户的请求转发到其他服务器上，并将其他服务器的处理结果返回给用户。
框架推荐 Controller 层主要对用户的请求参数进行处理（校验、转换），然后调用对应的 service 方法处理业务，得到业务结果后封装并返回：</li>
</ul>
<ol>
<li>获取用户通过 HTTP 传递过来的请求参数。</li>
<li>校验、组装参数。</li>
<li>调用 Service 进行业务处理，必要时处理转换 Service 的返回结果，让它适应用户的需求。</li>
<li>通过 HTTP 将结果响应给用户。</li>
</ol>
<pre><code class="ts language-ts">// app/controller/post.js
const Controller = require('egg').Controller;
class PostController extends Controller {
  async create() {
    const { ctx, service } = this;
    const createRule = {
      title: { type: 'string' },
      content: { type: 'string' },
    };
    // 校验参数
    ctx.validate(createRule);
    // 组装参数
    const author = ctx.session.userId;
    const req = Object.assign(ctx.request.body, { author });
    // 调用 Service 进行业务处理
    const res = await service.post.create(req);
    // 设置响应内容和响应状态码
    ctx.body = { id: res.id };
    ctx.status = 201;
  }
}
module.exports = PostController;
</code></pre>
<h3 id="service">Service</h3>
<p>简单来说，Service 就是在复杂业务场景下用于做业务逻辑封装的一个抽象层，提供这个抽象有以下几个好处：</p>
<ul>
<li>保持 Controller 中的逻辑更加简洁。</li>
<li>保持业务逻辑的独立性，抽象出来的 Service 可以被多个 Controller 重复调用。</li>
<li>将逻辑和展现分离，更容易编写测试用例，测试用例的编写具体可以查看这里。</li>
</ul>
<pre><code class="ts language-ts">// app/service/user.js
const Service = require('egg').Service;

class UserService extends Service {
  async find(uid) {
    const user = await this.ctx.db.query('select * from user where uid = ?', uid);
    return user;
  }
}

module.exports = UserService;
</code></pre>
<h3 id="helper">Helper</h3>
<p>Helper 用来提供一些实用的 utility 函数。它的作用在于我们可以将一些常用的动作抽离在 helper.js 里面成为一个独立的函数，这样可以用 JavaScript 来写复杂的逻辑，避免逻辑分散各处，同时可以更好的编写测试用例。</p>
<p>Helper 自身是一个类，有和 Controller 基类一样的属性，它也会在每次请求时进行实例化，因此 Helper 上的所有函数也能获取到当前请求相关的上下文信息。</p>
<pre><code class="ts language-ts">// app/controller/user.js
class UserController extends Controller {
  async fetch() {
    const { app, ctx } = this;
    const id = ctx.query.id;
    const user = app.cache.get(id);
    ctx.body = ctx.helper.formatUser(user);
  }
}
</code></pre>
<h3 id="config">Config</h3>
<h3 id="logger">Logger</h3>
<h3 id="subscription">Subscription</h3>
<p>订阅模型是一种比较常见的开发模式，譬如消息中间件的消费者或调度任务。因此我们提供了 Subscription 基类来规范化这个模式。</p>
<p>可以通过以下方式来引用 Subscription 基类：</p>
<pre><code class="ts language-ts">const Subscription = require('egg').Subscription;

class Schedule extends Subscription {
  // 需要实现此方法
  // subscribe 可以为 async function 或 generator function
  async subscribe() {}
}
</code></pre>
<h2 id="eggjskoa">Egg.js 与 Koa</h2>
<ol>
<li><p>Egg 继承于 Koa</p></li>
<li><p>Koa 中间件模型
<img src="https://camo.githubusercontent.com/d80cf3b511ef4898bcde9a464de491fa15a50d06/68747470733a2f2f7261772e6769746875622e636f6d2f66656e676d6b322f6b6f612d67756964652f6d61737465722f6f6e696f6e2e706e67" alt="Koa" /></p></li>
<li><p>Koa 中间件的<a href="https://zhuanlan.zhihu.com/p/141890366">实现原理</a></p></li>
</ol>
<p>例如添加一个异常处理的中间件：</p>
<pre><code class="ts language-ts">async function onerror(ctx, next) {
  try {
    await next();
  } catch (err) {
    ctx.app.emit('error', err);
    ctx.body = 'server error';
    ctx.status = err.status || 500;
  }
}
</code></pre>
<ol start="3">
<li>扩展
在基于 Egg 的框架或者应用中，我们可以通过定义 <code>app/extend/{application,context,request,response}.js</code> 来扩展 Koa 中对应的四个对象的原型，通过这个功能，我们可以快速的增加更多的辅助方法，例如我们在 app/extend/context.js 中写入下列代码：</li>
</ol>
<pre><code class="ts language-ts">// app/extend/context.js
module.exports = {
  get isIOS() {
    const iosReg = /iphone|ipad|ipod/i;
    return iosReg.test(this.get('user-agent'));
  },
};
</code></pre>
<pre><code class="ts language-ts">在 Controller 中，我们就可以使用到刚才定义的这个便捷属性了：

// app/controller/home.js
exports.handler = ctx =&gt; {
  ctx.body = ctx.isIOS
    ? 'Your operating system is iOS.'
    : 'Your operating system is not iOS.';
};
</code></pre>
<h2 id="-4">插件</h2>
<p>在 Express 和 Koa 中，经常会引入许许多多的中间件来提供各种各样的功能，例如引入 koa-session 提供 Session 的支持，引入 koa-bodyparser 来解析请求 body。而 Egg 提供了一个更加强大的插件机制，让这些独立领域的功能模块可以更加容易编写。</p>
<p>一个插件可以包含</p>
<p>extend：扩展基础对象的上下文，提供各种工具类、属性。
middleware：增加一个或多个中间件，提供请求的前置、后置处理逻辑。
config：配置各个环境下插件自身的默认配置项。
一个独立领域下的插件实现，可以在代码维护性非常高的情况下实现非常完善的功能，而插件也支持配置各个环境下的默认（最佳）配置，让我们使用插件的时候几乎可以不需要修改配置项。</p>
<p><a href="egg-security">https://github.com/eggjs/egg-security</a> 插件就是一个典型的例子。</p>]]></description><link>https://alyssaphacker.com/blog/egg</link><guid isPermaLink="true">https://alyssaphacker.com/blog/egg</guid><category><![CDATA[node]]></category><dc:creator><![CDATA[Zhongwei]]></dc:creator><pubDate>Mon, 29 Nov 2021 16:00:00 GMT</pubDate></item><item><title><![CDATA[Node介绍part 1]]></title><description><![CDATA[<h2 id="node">node 简史</h2>
<p>[http://nodejs.cn/learn/a-brief-history-of-nodejs]</p>
<h2 id="node-1">node 的优点</h2>
<ol>
<li>runtime: Node js 是一个开源和跨平台的 JavaScript 运行时环境</li>
<li>性能好:Node.js 在浏览器之外运行 V8 JavaScript 引擎（Google Chrome 的内核）</li>
<li>单线程管理数千链接，基于事件模型。适用于I/O密集型</li>
</ol>
<pre><code class="ts language-ts">const http = require('http')

const hostname = '127.0.0.1'
const port = 3000

const server = http.createServer((req, res) =&gt; {
  res.statusCode = 200
  res.setHeader('Content-Type', 'text/plain')
  res.end('Hello World\n')
})

server.listen(port, hostname, () =&gt; {
  console.log(`Server running at http://${hostname}:${port}/`)
})
</code></pre>
<h2 id="">安装</h2>
<ol>
<li>下载node binary, 设置环境变量, 轻量类似于python.</li>
<li>建议使用nvm管理不同node版本，方便切换不同的node版本</li>
</ol>
<h2 id="-1">异步编程</h2>
<ol>
<li>异步编程与回调</li>
<li>定时器</li>
<li>Promise</li>
<li>Async 与 Await</li>
<li>闭包</li>
<li>事件循环</li>
</ol>
<h2 id="-2">事件循环</h2>
<ol>
<li>Node.js JavaScript 代码运行在单个线程上。 每次只处理一件事。</li>
</ol>
<p>这个限制实际上非常有用，因为它大大简化了编程方式，而不必担心并发问题。</p>
<p>只需要注意如何编写代码，并避免任何可能阻塞线程的事情，例如同步的网络调用或无限的循环。</p>
<p>通常，在大多数浏览器中，每个浏览器选项卡都有一个事件循环，以使每个进程都隔离开，并避免使用无限的循环或繁重的处理来阻止整个浏览器的网页。</p>
<p>该环境管理多个并发的事件循环，例如处理 API 调用。 Web 工作进程也运行在自己的事件循环中。</p>
<p>主要需要关心代码会在单个事件循环上运行，并且在编写代码时牢记这一点，以避免阻塞它。</p>
<h3 id="-3">堆栈调用</h3>
<p>调用堆栈是一个 LIFO 队列（后进先出）。</p>
<p>事件循环不断地检查调用堆栈，以查看是否需要运行任何函数。</p>
<p>当执行时，它会将找到的所有函数调用添加到调用堆栈中，并按顺序执行每个函数。</p>
<p>你知道在调试器或浏览器控制台中可能熟悉的错误堆栈跟踪吗？ 浏览器在调用堆栈中查找函数名称，以告知你是哪个函数发起了当前的调用：</p>
<h3 id="-4">阻塞事件循环</h3>
<p>任何花费太长时间才能将控制权返回给事件循环的 JavaScript 代码，都会阻塞页面中任何 JavaScript 代码的执行，甚至阻塞 UI 线程，并且用户无法单击浏览、滚动页面等。</p>
<p>JavaScript 中几乎所有的 I/O 基元都是非阻塞的。 网络请求、文件系统操作等。 被阻塞是个异常，这就是 JavaScript 如此之多基于回调（最近越来越多基于 promise 和 async/await）的原因。</p>
<h3 id="-5">消息队列 与 作业队列</h3>
<p>什么属于消息队列事件</p>
<ol>
<li>setTimeout()</li>
<li>用户触发的事件比如键盘，单击, onLoad</li>
</ol>
<p>事件循环会赋予调用堆栈优先级，它首先处理在调用堆栈中找到的所有东西，一旦其中没有任何东西，便开始处理消息队列中的东西。
ECMAScript 2015 引入了作业队列的概念，Promise 使用了该队列（也在 ES6/ES2015 中引入）。 这种方式会尽快地执行异步函数的结果，而不是放在调用堆栈的末尾。</p>
<p>堆栈调用 -&gt; 作业队列 -&gt;  消息队列
有个游乐园中过山车的比喻很好：消息队列将你排在队列的后面（在所有其他人的后面），你不得不等待你的回合，而工作队列则是快速通道票，这样你就可以在完成上一次乘车后立即乘坐另一趟车。</p>
<pre><code class="ts language-ts">const bar = () =&gt; console.log('bar')

const baz = () =&gt; console.log('baz')

const foo = () =&gt; {
  console.log('foo')
  setTimeout(bar, 0)
  new Promise((resolve, reject) =&gt;
    resolve('应该在 baz 之后、bar 之前')
  ).then(resolve =&gt; console.log(resolve))
  baz()
}

foo()
</code></pre>]]></description><link>https://alyssaphacker.com/blog/node</link><guid isPermaLink="true">https://alyssaphacker.com/blog/node</guid><category><![CDATA[node]]></category><dc:creator><![CDATA[Zhongwei]]></dc:creator><pubDate>Mon, 29 Nov 2021 16:00:00 GMT</pubDate></item><item><title><![CDATA[Dan Abramov knows about Devii]]></title><description><![CDATA[<p>Dan Abramov knows about Devii!</p>
<blockquote>
  <p>Seems like it might be useful!
  — Dan Abramov, taken entirely out of context</p>
</blockquote>
<p>I don't want to brag, but Devii is kind of a big deal.</p>]]></description><link>https://alyssaphacker.com/blog/dan-abramov</link><guid isPermaLink="true">https://alyssaphacker.com/blog/dan-abramov</guid><category><![CDATA[Dan Abramov]]></category><dc:creator><![CDATA[Colin McDonnell]]></dc:creator><pubDate>Fri, 10 Jul 2020 23:51:18 GMT</pubDate></item><item><title><![CDATA[Choosing a tech stack for my personal dev blog in 2020]]></title><description><![CDATA[<blockquote>
  <p>Originally published at <a href="https://colinhacks.com/essays/devii">https://colinhacks.com/essays/devii</a>. Check out the HN <del>roast</del> discussion <a href="https://news.ycombinator.com/item?id=23309002">here</a>! 🤗</p>
</blockquote>
<p>I recently set out to build my personal website — the one you're reading now, as it happens!</p>
<p>Surprisingly, it was much harder than expected to put together a "tech stack" that met my criteria. My criteria are pretty straightforward; I would expect most React devs to have a similar list. Yet it was surprisingly hard to put all these pieces together.</p>
<p>Given the lack of a decent out-of-the-box solution, I worry that many developers are settling for static-site generators that place limits on the interactivity and flexibility of your website. We can do better.</p>
<blockquote>
  <p>Clone the repo here to get started with this setup: https://github.com/colinhacks/devii</p>
</blockquote>
<p>Let's quickly run through my list of design goals:</p>
<h3 id="reacttypescript">React (+ TypeScript)</h3>
<p>I want to build the site with React and TypeScript. I love them both wholeheartedly, I use them for my day job, and they're gonna be around for a long time. Plus writing untyped JS makes me feel dirty.</p>
<p>I don't want limitations on what my personal website can be/become. Sure, at present my site consists of two simple, static blog posts. But down the road, I may want to build a page that contains an interactive visualization, a filterable table, or a demo of a React component I'm open-sourcing. Even something simple (like the email newsletter signup form at the bottom of this page) was much more pleasant to implement in React; how did we use to build forms again?</p>
<p>Plus: I want access to the npm ecosystem and all my favorite UI, animation, and styling libraries. I sincerely hope I never write another line of raw CSS ever again; CSS-in-JS 4 lyfe baby. If you want to start a Twitter feud with me about this, by all means <a href="https://twitter.com/colinhacks">at me</a>.</p>
<h3 id="goodauthoringexperience">Good authoring experience</h3>
<p>If it's obnoxious to write new blog posts, I won't do it. That's a regrettable law of the universe. Even writing blog posts with plain HTML — just a bunch of <code>&lt;p&gt;</code> tags in a div — is just annoying enough to bug me. The answer: Markdown of course!</p>
<p>Static site generators (SSGs) like Hugo and Jekyll provide an undeniably wonderful authoring experience. All you have to do is <code>touch</code> a new .md file in the proper directory and get to writing. Unfortunately all Markdown-based SSGs I know of are too restrictive. Mixing React and Markdown on the same page is either impossible or tricky. If it's possible, it likely requires some plugin/module/extension, config file, blob of boilerplate, or egregious hack. Sorry Hugo, I'm not going to re-write my React code using <code>React.createElement</code> like it's 2015.</p>
<p>Well, that doesn't work for me. I want my website to be React-first, with a sprinkling of Markdown when it makes my life easier.</p>
<h3 id="staticgeneration">Static generation</h3>
<p>As much as I love the Jamstack, it doesn't cut it from an SEO perspective. Many blogs powered by a "headless CMS" require two round trips before rendering the blog content (one to fetch the static JS bundle and another to fetch the blog content from a CMS). This degrades page load speeds and user experience, which accordingly degrades your rankings on Google.</p>
<p>Instead I want every page of my site to be pre-rendered to a set of fully static assets, so I can deploy them to a CDN and get fast page loads everywhere. You could get the same benefits with server-side rendering, but that requires an actual server and worldwide load balancing to achieve comparable page load speeds. I love overengineering things as much as the next guy, even I have a line. 😅</p>
<h2 id="mysolution">My solution</h2>
<p>I describe my final architecture design below, along with my rationale for each choice. I distilled this setup into a website starter/boilerplate available here: https://github.com/colinhacks/devii. Below, I allude to certain files/functions I implemented; to see the source code of these, just clone the repo <code>git clone git@github.com:colinhacks/devii.git</code></p>
<h3 id="nextjs">Next.js</h3>
<p>I chose to build my site with Next.js. This won't be a surprising decision to anyone who's played with statically-rendered or server-side rendered React in recent years. Next.js is quickly eating everyone else's lunch in this market, especially Gatsby's (sorry Gatsby fans).</p>
<p>Next.js is by far the most elegant way (for now) to do any static generation or server-side rendering with React. They just released their next-generation (pun intended) static site generator in the <a href="https://nextjs.org/blog/next-9-3">9.3 release</a> back in March. So in the spirit of using technologies <a href="https://www.youtube.com/watch?v=eBAX8MbRYFA">in the spring of their life</a>, Next.js is a no-brainer.</p>
<p>Here's a quick breakdown of the project structure. No need to understand every piece of it; but it may be useful to refer to throughout the rest of this post.</p>
<pre><code>.
├── README.md
├── public // all static files (images, etc) go here
├── pages // every .tsx component in this dir becomes a page of the final site
|   ├── index.tsx // the home page (which has access to the list of all blog posts)
|   ├── blog
|       ├── [blog].md // a template component that renders the blog posts under `/md/blog`
├── md
|   ├── blog
|       ├── devii.md // this page!
        ├── whatever.md // every MD file in this directory becomes a blog post
├── components
|   ├── Code.tsx
|   ├── Markdown.tsx
|   ├── &lt;various others&gt;
├── loader.ts // contains utility functions for loading/parsing Markdown
├── node_modules
├── tsconfig.json
├── package.json
├── next.config.js
├── next-env.d.ts
├── .gitignore
</code></pre>
<!-- Check out the Next.js documentation [here](https://nextjs.org/docs) to make sure it's the right choice for your project. -->
<h3 id="typescriptreact">TypeScript + React</h3>
<p>Both React and TypeScript are baked into the DNA of Next.js, so you get these for free when you set up a Next.js project.</p>
<p>Gatsby, on the other hand, has a special plugin for TypeScript support, but it's not officially supported and seems to be <a href="https://github.com/gatsbyjs/gatsby/issues/18983">low on their priority list</a>. Also, after messing with it for an hour I couldn't get it to play nice with hot reload.</p>
<h3 id="markdownauthoring">Markdown authoring</h3>
<p>Using Next's special <code>getStaticProps</code> hook and glorious <a href="https://nextjs.org/docs/advanced-features/dynamic-import#with-no-ssr">dynamic imports</a>, it's trivial to a Markdown file and pass its contents into your React components as a prop. This achieves the holy grail I was searching for: the ability to easily mix React and Markdown.</p>
<h4 id="frontmattersupport">Frontmatter support</h4>
<p>Every Markdown file can include a "frontmatter block" containing metadata. I implemented a simple utility function (<code>loadPost</code>) that loads a Markdown file, parses its contents, and returns a TypeScript object with the following signature:</p>
<pre><code class="ts language-ts">type PostData = {
  path: string; // the relative URL to this page, can be used as an href
  content: string; // the body of the MD file
  title?: string;
  subtitle?: string;
  date?: number;
  author?: string;
  authorPhoto?: string;
  authorTwitter?: string;
  tags?: string[];
  bannerPhoto?: string;
  thumbnailPhoto?: string;
};
</code></pre>
<p>I implemented a separate function <code>loadPosts</code> that loads <em>all</em> the Markdown files under <code>/md/blog</code> and returns them as an array (<code>PostData[]</code>). I use <code>loadPosts</code> on this site's home page to render a list of all posts I've written.</p>
<h3 id="mediuminspireddesign">Medium-inspired design</h3>
<p>I used the wonderful <a href="https://github.com/rexxars/react-markdown"><code>react-markdown</code></a> package to render Markdown as a React component. My Markdown rendered component (<code>/components/Markdown.tsx</code>) provides some default styles inspired by Medium's design. Just modify the <code>style</code> pros in <code>Markdown.tsx</code> to customize the design to your liking.</p>
<h3 id="githubstylecodeblocks">GitHub-style code blocks</h3>
<p>You can easily drop code blocks into your blog posts using triple-backtick syntax. Specify the programming language with a "language tag", <a href="https://help.github.com/en/github/writing-on-github/creating-and-highlighting-code-blocks">just like GitHub</a>!</p>
<p>To achieve this I implemented a custom <code>code</code> renderer (<code>/components/Code.tsx</code>) for <code>react-markdown</code> that uses <a href="https://github.com/conorhastings/react-syntax-highlighter#readme">react-syntax-highlighter</a> to handle the highlighting. So this:</p>
<!-- I landed on this solution after wasting hours playing with other options. CodeMirror has bad React support (the only React wrapper for it is inauspiciously named `react-codemirror2`) and [bizarre selection issues](https://github.com/codemirror/CodeMirror/issues/1099) for `readonly` code blocks. The popular `highlight.js` project requires you to [initialize the library](https://github.com/highlightjs/highlight.js/issues/925) in `componentDidMount` like its 2015 :/  -->
<pre><pre><code class="ts language-ts">// pretty neat huh?
const test = (arg: string) =&gt; {
  return arg.length &gt; 5;
};
</code></pre></pre>
<p>turns into this:</p>
<pre><code class="ts language-ts">// pretty neat huh?
const test = (arg: string) =&gt; {
  return arg.length &gt; 5;
};
</code></pre>
<h3 id="rssfeedgeneration">RSS feed generation</h3>
<p>An RSS feed is auto-generated from your blog post feed. This feed is generated using the <code>rss</code> module (for converting JSON to RSS format) and <code>showdown</code> for converting the markdown files to RSS-compatible HTML. The feed is generated during the build step and written as a static file to <code>/rss.xml</code> in your static assets folder. It's dead simple. That's the joy of being able to easily write custom build scripts on top of Next.js's <code>getStaticProps</code> hooks!</p>
<h3 id="seo">SEO</h3>
<p>Every blog post page automatically populated meta tags based on the post metadata. This includes a <code>title</code> tag, <code>meta</code> tags, <code>og:</code> tags, Twitter metadata, and a <code>link</code> tag containing the canonical URL. You can modify/augment this in the <code>PostMeta.ts</code> component.</p>
<h3 id="staticgeneration-1">Static generation</h3>
<p>You can generate a fully static version of your site using <code>yarn build &amp;&amp; yarn export</code>. This step is entirely powered by Next.js. The static site is exported to the <code>out</code> directory.</p>
<p>After its generated, use your static file hosting service of choice (Firebase Hosting, Vercel, Netlify) to deploy your site.</p>
<h3 id="insanelycustomizable">Insanely customizable</h3>
<p>There's nothing "under the hood" here. You can view and modify all the files that provide the functionality described above. Devii just provides a project scaffold, some Markdown-loading loading utilities (in <code>loader.ts</code>), and some sensible styling defaults (especially in <code>Markdown.tsx</code>).</p>
<p>To start customizing, modify <code>index.tsx</code> (the home page), <code>Essay.tsx</code> (the blog post template), and <code>Markdown.tsx</code> (the Markdown renderer).</p>
<h2 id="getstarted">Get started</h2>
<p>Head to the GitHub repo to get started: <a href="https://github.com/colinhacks/devii">https://github.com/colinhacks/devii</a>. If you like this project, leave a ⭐️star⭐️ to help more people find Devii! 😎</p>
<p>To jump straight into the code, clone the repo and start the development server like so:</p>
<pre><code class="bash language-bash">git clone git@github.com:colinhacks/devii.git mysite
cd mysite
yarn
yarn dev
</code></pre>]]></description><link>https://alyssaphacker.com/blog/the-ultimate-tech-stack</link><guid isPermaLink="true">https://alyssaphacker.com/blog/the-ultimate-tech-stack</guid><category><![CDATA[Static Site Generators]]></category><category><![CDATA[React]]></category><category><![CDATA[Next.js]]></category><dc:creator><![CDATA[Colin McDonnell]]></dc:creator><pubDate>Tue, 26 May 2020 03:18:56 GMT</pubDate></item><item><title><![CDATA[Devii's killer features]]></title><description><![CDATA[<p>This page is built with Devii! Check out the source code for this under <code>/md/blog/test.md</code>.</p>
<p>Devii is a starter kit for building a personal website with the best tools 2020 has to offer.</p>
<ul>
<li><strong>Markdown-based</strong>: Just add a Markdown file to <code>/md/blog</code> to add a new post to your blog!</li>
<li><strong>TypeScript + React</strong>: aside from the parts that are rendered Markdown, everything else is fully built with TypeScript and functional React components. Implementing any sort of interactive widget is often hard using existing Markdown-centric static-site generators, but Devii makes it easy to mix Markdown and React on the same page.</li>
<li><strong>Frontmatter support</strong>: Every post can include a frontmatter block containing metadata: <code>title</code>, <code>subtitle</code>, <code>datePublished</code> (timestamp), <code>author</code>, <code>authorPhoto</code>, and <code>bannerPhoto</code>.</li>
<li><strong>Medium-inspired styles</strong>: The Markdown renderer (<code>Markdown.tsx</code>) contains default styles inspired by Medium.</li>
<li><strong>Static generation</strong>: you can generate a fully static version of your site using <code>yarn build &amp;&amp; yarn export</code>. Powered by Next.js.</li>
<li><strong>GitHub-style code blocks</strong>: with syntax highlighting powered by <a href="https://github.com/conorhastings/react-syntax-highlighter">react-syntax-highlighter</a>. Works out-of-the-box for all programming languages. Just use Markdown's triple backtick syntax with a "language identifier", <a href="https://help.github.com/en/github/writing-on-github/creating-and-highlighting-code-blocks">just like GitHub</a>.</li>
</ul>
<pre><code class="ts language-ts">  // pretty neat huh?
  const test: (arg: string) =&gt; boolean = (arg) =&gt; {
    return arg.length &gt; 5;
  };
</code></pre>
<ul>
<li><strong>Utterly customizable</strong>: We provide a minimal interface to get you started, but you can customize every aspect of the rendering and styling by just modifying <code>index.tsx</code> (the home page), <code>BlogPost.tsx</code> (the blog post template), and <code>Markdown.tsx</code> (the Markdown renderer). And of course you can add entirely new pages as well!</li>
</ul>
<p>Head to the GitHub repo to get started: <a href="https://github.com/colinhacks/devii">https://github.com/colinhacks/devii</a>. If you like this project, leave a ⭐️star⭐️ to help more people find Devii 😎</p>]]></description><link>https://alyssaphacker.com/blog/devii</link><guid isPermaLink="true">https://alyssaphacker.com/blog/devii</guid><category><![CDATA[Devii]]></category><category><![CDATA[Blogs]]></category><dc:creator><![CDATA[Ben Bitdiddle]]></dc:creator><pubDate>Sat, 09 May 2020 22:48:42 GMT</pubDate></item></channel></rss>